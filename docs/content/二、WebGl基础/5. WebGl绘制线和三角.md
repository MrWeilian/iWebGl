# 5. WebGl绘制线和三角

经过前面几个小节的学习，我们已经学习了点的绘制；一些相关的 GLSL 语法、内置变量和写法，那么从这一节开始，我们将继续深入了解**缓冲区对象**，通过 WebGl 来绘制线和面。

虽说是用 WebGl 绘制线和面，但其实大家应该早就知道了 3D 图形的基本单位是三角形，也就是三角形是所有面、3D 图形的基础。我们可以直接在 [three.js](https://threejs.org/examples/#webgl_camera) 的这个 demo，很显然立体图形是通过拼合多个三角形构成的，所以说**三角形是 3D 图形的基础**。

![5.1](../../public/images/second/5.1.png)

## 缓冲区对象

我们想一想，缓冲区对象是什么？为什么需要缓冲区对象？

回顾之前我们绘制点的做法，我们都是通过 `gl.drawArrays()` 来实现单个点的绘制，而且当时我们还简单介绍了一下这个 api 的用法（[第2小节](/content/二、WebGl基础/2.%20WebGl绘制点.html)）。我们在这里简单回顾一下：

| api       | 参数值 | 参数值说明 | 返回值                              |
|--------------|------|-----------------------------------|--|
| [gl.drawArrays](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays) | (mode, first, count) | 1. mode：<br>`gl.POINTS` 绘制单个点<br>2. first：<br>指定开始绘制的点<br>3. count：<br>指定绘制多少个点 | - |

可以看到参数值说明，我们之前只了解了其中一个 mode 值——`gl.POINTS`。那其实 mode 还有其他的参数值，比如：
- `gl.LINE_STRIP`
- `gl.LINE_LOOP`
- `gl.TRIANGLES`

等等...我们通过它的英文名称不难发现 points 、line 、triangles 不就是 点、线、三角形吗？没错，其实我们改变 `gl.drawArrays` 这个 api 的 mode 的参数值，WebGl 就帮我们绘制对应的图形。

那么问题来了，之前我们绘制一个点的时候只需要传入一个点的坐标位置给到 `gl_Position` 即可，但是我们现在**绘制线和三角形**，最少一次调用 `gl.drawArrays` 之前都得设置两个以上的顶点坐标值对吧？所以，这个时候我们就需要**缓冲区对象**了。

缓冲区对象可以**一次性传入多个顶点数据**（包括但不限于坐标数据，还可以有颜色和其他的），保存在缓冲区中，后续顶点着色器、片元着色器就可以使用里面的数据。

我们通过下图来大概了解缓冲区的应用过程：
1. js 中定义了 `Float32Array` 类型的数组（我们可以简单理解为普通 js 数组）
2. 将 js 数组传递并存储于缓冲区对象中
3. `gl.drawArrays()` 绘制时，顶点、片元着色器可以通过缓冲区读取多个顶点数据
![5.2](../../public/images/second/5.2.png)

图画得比较简单，一时没看懂没关系，我们接着往下走，当你使用缓冲区成功绘制出线、三角形的时候再回来看这个图会有更深的理解。

## 使用WebGl缓冲区

缓冲区的使用遵循一个步骤，其中也会涉及到一些新的 api ，我们一步一步来看：
1. 通过 `gl.createBuffer` 创建缓冲区对象
2. 通过 `gl.bindBuffer` 绑定缓冲区对象（无法直接操作缓冲区对象）
3. 通过 `gl.bufferData` 写入缓冲区数据，如上图中的 `Float32Array` 数据
4. 通过 `gl.vertexAttribPointer` 将缓冲区数据分配到 `attribute` 变量
5. 通过 `gl.enableVertexAttribArray` 开启 `attribute` 变量

好像是稍微有那么一点复杂，涉及各种 api 的使用和参数传递，但是其实我们可以在学习之后自行将其进行一定的封装，沉淀为一个工具函数。处于学习阶段的我们需要掌握它，所以还是有必要了解每一个步骤。那接下来，我们一步一步的来展开说说吧！

### 1. 创建缓冲区对象

首先是创建缓冲区对象，我们可以在 [MDN-gl.createBuffer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createBuffer) 看看这个 api 的具体用法，这个算是非常简单了，因为我们不需要管任何参数！

```js
// 直接调用创建缓冲区对象
const buffer = gl.createBuffer()
```

当我们执行了这行代码，相当于在 WebGl 中创建了一个缓冲区对象：

![5.3](../../public/images/second/5.3.png)

顺带提一下，有来就有回，有创建就有删除！我们可以通过 [gl.deleteBuffer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/deleteBuffer) 来删除对应的缓冲区（了解一下，不属于本节重点）。

### 2. 绑定缓冲区对象

关于这一步，我们可以这样理解：上文有提到一点**不能直接操作缓冲区对象**，所以我们需要把缓冲区对象需要绑定到一个 target 上，然后我们去操作 target。其实可以类比成 es6 的 `Proxy`，将这一步理解为一个代理的概念。

我们可以先通过 [MDN-gl.bindBuffer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer) 来了解这个 api 的基本用法。

1. 它的第一个参数——`target`。

| target                                                                                                         | 参数值说明                                  |
|----------------------------------------------------------------------------------------------------------------|---------------------------------------------|
| `gl.ARRAY_BUFFER`                                                                                              | 包含顶点属性的 Buffer，如坐标数据、颜色数据 |
| `gl.ELEMENT_ARRAY_BUFFER`                                                                                      | 包含顶点的索引值 Buffer                     |
| [WebGl2相关参数](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer#parameters) | （感兴趣可以去 MDN 里看，本节暂时不涉及）   |

我们可以发现有 target 的类型有很多，本节我们只关注 `gl.ARRAY_BUFFER` 即可。根据 MDN 对他的描述，我们可以知道他是**作为包含顶点属性 Buffer 的一个 target**，又因为我们目前通过 Buffer 存放我们 N 个**顶点的坐标**，所以我们将 Buffer 绑定到它身上。

2. 它的第二个参数——`buffer`

这个就没什么好说的了，他就是我们创建的 Buffer ，也就是上文提到的 `gl.createBuffer()` 的返回值。

相应的代码实现如下：
```js
// 第一个参数 target；第二个参数 buffer
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
```

那么此时，我们将刚才创建的一个缓冲区对象绑定到了 `gl.ARRAY_BUFFER` 这个 target 上：

![5.4](../../public/images/second/5.4.png)

### 3. 缓冲区写入数据

:::demo
basic/5_1
:::
