# 4. 图形的复合变换

上一小节我们通过对矩阵乘矢量的自行推导，实战了矩阵在 WebGL 中的应用，成功实现了图形的平移效果。那么这一节，我们继续深入矩阵在 WebGL 中的应用，实战图形**平移+旋转**的复合变换效果。

## 复合变换和矩阵

相信现在的你对于矩阵在 WebGL 中的妙用已经稍有体会了，毕竟平移、缩放、旋转都可以通过矩阵乘法来实现，并且其极大的简化我们着色器中的公式应用，实现一种着色器代码走天下的效果～那你又知不知道**矩阵在复合变换中同样适用**呢？

首先我们抛开矩阵，看看直接写表达式要怎么实现**平移+旋转**的复合变换。

```js
const vertexCode = `
  attribute vec4 a_Position;
  attribute vec4 a_Color;
  varying vec4 v_Color;
  uniform float u_Rotate;
  uniform vec4 u_Position;

  void main () {
    // 两矢量相加
    gl_Position = vec4(
      a_Position.x * cos(u_Rotate) - a_Position.y * sin(u_Rotate), 
      a_Position.x * sin(u_Rotate) + a_Position.y * cos(u_Rotate), 
      0., 
      1.
    ) + u_Position;
    v_Color= a_Color;
  }
`
```

那么根据 [本章第 1 节](/content/四、WebGL二维动画/1.%20会动的三角形.html) 的等式，我们大概可以推出**平移+旋转**的着色器代码如上。这里我们把两个矢量进行相加，一个是计算旋转后的 `vec4` 坐标点，一个是平移产生的位移值 `u_Position`。

还是上一节说过的，通过数学等式的组合并不是不可以实现复合变换，只是针对每种变换我们都得实现一个对应的 shader，所以我们依然坚定地把目光转向矩阵！看看这个神奇的数学工具在复合变换中的应用！

既然是要实现平移+旋转的复合变换，那我们依然可以将其一一拆开来做一定的推导！回顾我们上一节用矩阵实战**平移**的核心着色器代码如下：

```C
// 平移矩阵 x 顶点坐标
gl_Position = u_TranslateMatrix * a_Position;
```

那其实对于**旋转**的变换，我们依然可以使用上述的矩阵乘法矢量的等式来实现，只是需要**传入的矩阵跟平移的矩阵不一样**而已。所以旋转的着色器核心实现依然是一样的等式：

```C
// 旋转矩阵 x 顶点坐标
gl_Position = u_RotateMatrix * a_Position;
```

虽然我们现在需要复合平移和旋转两种变换效果，但是从分解后来看，无非就是**先平移**一个顶点坐标然后**再将其进行一定角度的旋转**就可以实现了。那换算到上述的等式中，我们其实可以这样写：

```C
// 旋转矩阵 x 平移后的坐标矢量
gl_Position = u_RotateMatrix * (u_TranslateMatrix * a_Position);
```

那么回顾 [矩阵乘法](/content/四、WebGL二维动画/2.%20图形学的数学基础.html#_2-矩阵乘法) 小节，我们知道矩阵乘法遵循结合律。也就是上述等式我们可以换算成：

```C
// (旋转矩阵 x 平移矩阵) x 顶点坐标
gl_Position = (u_RotateMatrix * u_TranslateMatrix) * a_Position;
```

根据矩阵乘法的规则，我们两个 `4x4` 矩阵相乘的结果**依然是一个 `4x4` 矩阵**。所以上述等式可以再进一步推导回最初**矩阵乘矢量**的模式：

```C
// 模型矩阵 x 顶点坐标
gl_Position = u_ModelMatrix * a_Position;
```

上述代码中的 `u_ModelMatrix` 为 **模型矩阵**，这个模型矩阵是通过**多个变换矩阵的结合**得到的（本例中是平移和旋转矩阵的复合）。经历过一次次地推导，我们又回到了最初的起点——**矩阵乘矢量**。所以，现在你应该更深刻地体会到矩阵对于 WebGL 的意义了吧？

## JavaScript与矩阵

经过上述推导，我们得到了最新的复合变换等式：
- `gl_Position = u_ModelMatrix * a_Position`

这个等式跟上一节我们实现图形平移是一样的，只是 `u_ModelMatrix` 是通过复合多个变换后得到的矩阵而已。

这也就意味着，我们在 JavaScript 中计算好 `平移矩阵 x 旋转矩阵` 的值后，再传递给到着色器就可以实现图形的复合变换了。但是，JavaScript 并不像 GLSL 那样原生支持矩阵、矩阵乘法，要是再像上一小节那样手动写矩阵，然后还要运算他们的乘法就很蛋疼了...

所以这个时候，我不由自主的打开了 Google，找个库用去！

:::demo
fourth/4_1
:::